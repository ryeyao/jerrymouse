# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

fileClassLoader.canRead=Repository {0} cannot be read
fileClassLoader.exists=Repository {0} does not exist
fileClassLoader.jarFile=Cannot read JAR file {0}
fileClassLoader.restricted=Cannot load restricted class {0}
standardLoader.addRepository=Adding repository {0}
standardLoader.alreadyStarted=Loader has already been started
standardLoader.checkInterval=Cannot set reload check interval to {0} seconds
standardLoader.notContext=Cannot auto-reload unless our Container is a Context
standardLoader.notReloadabe=Reloadable property is set to false
standardLoader.notStarted=Loader has not yet been started
standardLoader.reloadable=Cannot set reloadable property to {0}
standardLoader.reloading=Reloading checks are enabled for this Context
standardLoader.removeRepository=Removing repository {0}
standardLoader.starting=Starting this Loader
standardLoader.stopping=Stopping this Loader
virtualComponentLoader.token=Processing token [{0}]
virtualComponentLoader.token.file=Adding location: [{0}]
virtualComponentLoader.token.glob.dir=Listing files in a directory: [{0}]
virtualComponentLoader.token.notDirectory=Path is skipped, because it does not exist or is not a directory: [{0}]
virtualComponentLoader.token.notExists=Path is skipped, because it does not exist: [{0}]
virtualComponentLoader.token.notFile=Path is skipped, because it does not exist or is not a file: [{0}]
componentClassLoader.illegalJarPath=Illegal JAR entry detected with name {0}
componentClassLoader.jdbcRemoveFailed=JDBC driver de-registration failed for component [{0}]
componentClassLoader.jdbcRemoveStreamError=Exception closing input stream during JDBC driver de-registration for component [{0}]
componentClassLoader.stopped=Illegal access: this component instance has been stopped already.  Could not load {0}.  The eventual following stack trace is caused by an error thrown for debugging purposes as well as to attempt to terminate the thread which caused the illegal access, and has no functional impact.
componentClassLoader.readError=Resource read error: Could not load {0}.
componentClassLoader.clearJdbc=The component [{0}] registered the JDBC driver [{1}] but failed to unregister it when the component was stopped. To prevent a memory leak, the JDBC Driver has been forcibly unregistered.
componentClassLoader.clearReferencesResourceBundlesCount=Removed [{0}] ResourceBundle references from the cache for component [{1}]
componentClassLoader.clearReferencesResourceBundlesFail=Failed to clear ResourceBundle references for component [{0}]
componentClassLoader.clearRmiInfo=Failed to find class sun.rmi.transport.Target to clear context class loader for component [{0}]. This is expected on non-Sun JVMs.
componentClassLoader.clearRmiFail=Failed to clear context class loader referenced from sun.rmi.transport.Target for component [{0}]
componentClassLoader.checkThreadLocalsForLeaks.badKey=Unable to determine string representation of key of type [{0}]
componentClassLoader.checkThreadLocalsForLeaks.badValue=Unable to determine string representation of value of type [{0}]
componentClassLoader.checkThreadLocalsForLeaks.unknown=Unknown
componentClassLoader.checkThreadLocalsForLeaks=The component [{0}] created a ThreadLocal with key of type [{1}] (value [{2}]) and a value of type [{3}] (value [{4}]) but failed to remove it when the component was stopped. Threads are going to be renewed over time to try and avoid a probable memory leak.
componentClassLoader.checkThreadLocalsForLeaksDebug=The component [{0}] created a ThreadLocal with key of type [{1}] (value [{2}]). The ThreadLocal has been correctly set to null and the key will be removed by GC.
componentClassLoader.checkThreadLocalsForLeaksFail=Failed to check for ThreadLocal references for component [{0}]
componentClassLoader.checkThreadsHttpClient=Found HttpClient keep-alive thread using component class loader. Fixed by switching thread to the parent class loader.
componentClassLoader.getThreadGroupError=Unable to obtain the parent for ThreadGroup [{0}]. It will not be possible to check all threads for potential memory leaks
componentClassLoader.loadedByThisOrChildFail=Failed to fully check the entries in an instance of [{0}] for potential memory leaks in context [{1}]
componentClassLoader.stopThreadFail=Failed to terminate thread named [{0}] for component [{1}]
componentClassLoader.stopTimerThreadFail=Failed to terminate TimerThread named [{0}] for component [{1}]
componentClassLoader.validationErrorJarPath=Unable to validate JAR entry with name {0}
componentClassLoader.warnRequestThread=The component [{0}] is still processing a request that has yet to finish. This is very likely to create a memory leak. You can control the time allowed for requests to finish by using the unloadDelay attribute of the standard Context implementation.
componentClassLoader.warnThread=The component [{0}] appears to have started a thread named [{1}] but has failed to stop it. This is very likely to create a memory leak.
componentClassLoader.warnTimerThread=The component [{0}] appears to have started a TimerThread named [{1}] via the java.util.Timer API but has failed to stop it. To prevent a memory leak, the timer (and hence the associated thread) has been forcibly canceled.
componentClassLoader.wrongVersion=(unable to load class {0})
componentLoader.addRepository=Adding repository {0}
componentLoader.deploy=Deploying class repositories to work directory {0}
componentLoader.jarDeploy=Deploy JAR {0} to {1}
componentLoader.classDeploy=Deploy class files {0} to {1}
componentLoader.alreadyStarted=Loader has already been started
componentLoader.checkInterval=Cannot set reload check interval to {0} seconds
componentLoader.notContext=Cannot auto-reload unless our Container is a Context
componentLoader.notReloadabe=Reloadable property is set to false
componentLoader.notStarted=Loader has not yet been started
componentLoader.loading=Loading component {0}
componentLoader.loadFailure=Fail to load component {0}
componentLoader.loaded=Component {0} loaded sucessfully
componentLoader.reloadable=Cannot set reloadable property to {0}
componentLoader.reloading=Reloading checks are enabled for this Context
componentLoader.removeRepository=Removing repository {0}
componentLoader.starting=Starting this Loader
componentLoader.stopping=Stopping this Loader
componentLoader.failModifiedCheck=Error tracking modifications
componentLoader.copyFailure=Failed to copy resources
componentLoader.mkdirFailure=Failed to create destination directory to copy resources
componentLoader.namingFailure=Failed to access resource {0}
